/*
 * GccApplication4.c
 *
 * Created: 14-02-2020 22:44:30
 *  Author: yadav
 */ 

#include <stdio.h>
#include <stdlib.h>
#include <avr/io.h>
typedef int bool;
#define TRUE  1
#define FALSE 0
#define  F_CPU 14745600
#define stepc 1
#define stepac 0
#define clk 1
#define anclk 0
#define byte uint8_t
#include <avr/interrupt.h>
#include <util/delay.h>
int sensor_values[3];
////////////////////////////////////////////all about motor///////////////////////////////////////////////////////////////////////////
int left=0;
int right=0;
int wls_left;
int wls_middle;
int wls_right;
int count=0;
int stepper_count=0;
//LCD definition......................................///////////////////////////////////////
#define LCD_Data_Dir DDRK		/* Define LCD data port direction */
#define LCD_Command_Dir DDRC		/* Define LCD command port direction register */
#define LCD_Data_Port PORTK		/* Define LCD data port */
#define LCD_Command_Port PORTC		/* Define LCD data port */
#define RS PC0				/* Define Register Select (data/command reg.)pin */
#define RW PC1				/* Define Read/Write signal pin */
#define EN PC2				/* Define Enable signal pin */
///////////////////////////////////////////////////////////////////////////////////////////////



void left_encoder_pin_config (void) //Configure Interrupt 6
{
	DDRE = DDRE & 0x9F; //Set the direction of the PORTE 6 pin as input
	PORTE = PORTE | 0x40; //Enable internal pull-up for PORTE 6 pin
}

void right_encoder_pin_config (void) //Configure Interrupt 5
{
	DDRE = DDRE & 0xDF; //Set the direction of the PORTE 5 pin as input
	PORTE = PORTE | 0x20; //Enable internal pull-up for PORTE 5 pin
}
void left_position_encoder_interrupt_init (void) //Interrupt 4 enable
{
	cli(); //Clears the global interrupt
	EICRB = EICRB | 0x20; // INT6 is set to trigger with falling edge
	EIMSK = EIMSK | 0x40; // Enable Interrupt INT6 for left position encoder
	sei(); // Enables the global interrupt
}
void right_position_encoder_interrupt_init (void) //Interrupt 5 enable
{
	cli(); //Clears the global interrupt
	EICRB = EICRB | 0x08; // INT5 is set to trigger with falling edge
	EIMSK = EIMSK | 0x20; // Enable Interrupt INT5 for left position encoder
	sei(); // Enables the global interrupt
}
ISR(INT6_vect)
{
	left+=1;
}
ISR(INT5_vect)
{
	right+=1;
}





//graph definition......................................///////////////////////////////////////
#define INFINITY 99
#define MAX 16
void dijkstra(int G[MAX][MAX],int n,int startnode,int lastnode);
int path[15][15];
int step=0;
///////////////////////////////////////////////////////////////////////////////////////////////



//movement definitions..................................///////////////////////////////////////
#define clk 1
#define anclk 0
int direction=0;
int f=0;
///////////////////////////////////////////////////////////////////////////////////////////////



//functions definitions..................................//////////////////////////////////////
bool to_pick = TRUE;
void picking(int material);
void placing(int house,int i);
void travel(int p1, int p2);
void wall_follower(void);
bool is_white_Node(void);
void white_right_turn_wls(void);
void white_left_turn_wls(void);
void LCD_Command(unsigned char cmnd);
void LCD_Char (unsigned char char_data);
void LCD_Init (void);
void LCD_String (char *str)	;
void LCD_String_xy (char row, char pos, char *str);
void LCD_Clear();
void wls_print();
void buzzer();
void turn_180();
void servo1(int initial,int final);
void servo2(int initial,int final);
void servo3(int initial,int final);
void servo4(int initial,int final);
void velocity (unsigned char left_motor, unsigned char right_motor);
void read_wls(void);
void stopmm();
void forward();
void backward();
void turn_right();
void turn_left();
void soft_right();
void soft_left();
void pick_bot();
void place_lr();
void place_hr();
void place_in(int d, int pi, int pl);
void pick_from(int d, int a, int p);
void papom( int pick, int place,int node);
void stepper(int rot, int deg);
void wall_follower();
void ir();
void forward_wls_zz(int node,int speed);
void line_follower();
void make_path();
///////////////////////////////////////////////////////////////////////////////////////////////



//global variables assignment..................................////////////////////////////////

int wls_left, wls_right, wls_middle;
int ir_left,ir_right;
int count1=0;
unsigned char new_state='r';
///////////////////////////////////////////////////////////////////////////////////////////////


void all_init()
{
	
	//stepper connections
	//DDRA=0x3F;
	//PORTA =0x20;
	
	//direction 0   anticlockwise
	//direction 1   clockwise
	
	
	
	//step A0			 1
	//direction A1		 2
	//MS1 A2			 4
	//MS2 A3			 8
	//MS3 A4			 10
	//Enable A5			 20
	
	//left motor pins 0 and 1
	//right motor pins 2 and 3
	DDRD=0x0f;
	PORTD =0x00;
	DDRL=0xFF;
	PORTL=0xFF;
	DDRH=0xFF;
	PORTH=0xFF;
	//timer setup.........................
	//left and right motors pwm speed registers()
	TCCR5A = 0xA9;
	TCCR5B = 0x0B;
	TCNT5H = 0xFF;
	TCNT5L = 0x00;
	OCR5AH = 0x00;//PL3
	OCR5AL = 0xFF;
	OCR5BH = 0x00;//PL4
	OCR5BL = 0xFF;
	
	
	//servo connections
	DDRB=0xFF;
	PORTB=0xff;
	DDRH=0xFF;
	PORTH=0xff;
	DDRE=0xFF;
	PORTE=0xff;
	
	//Servos pwm registers
	// 	TCCR1A = 0xA9;
	// 	TCCR1B = 0x0B;
	// 	TCNT1H = 0xFF;
	// 	TCNT1L = 0x00;
	// 	OCR1AH = 0x00;    //PB5  servo 4
	// 	OCR1AL = 0xFF;
	// 	OCR1BH = 0x00;   //PB6   servo 3
	// 	OCR1BL = 0xFF;
	// 	OCR1CH = 0x00;   //PB7   servo 2
	// 	OCR1CL = 0xFF;

	TCCR1A|=(1<<COM1A1)|(1<<COM1B1)|(1<<WGM11);        //NON Inverted PWM
	TCCR1B|=(1<<WGM13)|(1<<WGM12)|(1<<CS11)|(1<<CS10); //PRESCALER=64 MODE 14(FAST PWM)

	ICR1=4999;  //fPWM=50Hz (Period = 20ms Standard).
	
	TCCR4A|=(1<<COM4A1)|(1<<COM4B1)|(1<<WGM41);        //NON Inverted PWM//ph3>>oc4a/ph4>>oc4b
	TCCR4B|=(1<<WGM43)|(1<<WGM42)|(1<<CS41)|(1<<CS40); //PRESCALER=64 MODE 14(FAST PWM)

	ICR4=4999;  //fPWM=50Hz (Period = 20ms Standard).

	TCCR3A|=(1<<COM3A1)|(1<<COM3B1)|(1<<WGM31);        //NON Inverted PWM
	TCCR3B|=(1<<WGM33)|(1<<WGM32)|(1<<CS31)|(1<<CS30); //PRESCALER=64 MODE 14(FAST PWM)

	ICR3=4999;  //fPWM=50Hz (Period = 20ms Standard).
	
	
	
	//servo initial positions.............................................
	OCR3A=97;        //servo 00
	OCR3B=97;	//SERVO01
	OCR4A=365;    //SERVO1
	//Wait();
	OCR4B=450;    //SERVO2
	// Wait();
	OCR1B=316;		//SERVO3
	OCR1A=300;		//SERVO4
	LCD_Init();
	left_encoder_pin_config();
	right_encoder_pin_config();
	left_position_encoder_interrupt_init();
	right_position_encoder_interrupt_init();
	
}

//LCD functions ..................................///////////////////////////////////////////////////////////////////////////////////


void LCD_Command(unsigned char cmnd)
{
	LCD_Data_Port= cmnd;
	LCD_Command_Port &= ~(1<<RS);	/* RS=0 command reg. */
	LCD_Command_Port &= ~(1<<RW);	/* RW=0 Write operation */
	LCD_Command_Port |= (1<<EN);	/* Enable pulse */
	_delay_us(1);
	LCD_Command_Port &= ~(1<<EN);
	_delay_ms(3);
}

void LCD_Char (unsigned char char_data)	/* LCD data write function */
{
	LCD_Data_Port= char_data;
	LCD_Command_Port |= (1<<RS);	/* RS=1 Data reg. */
	LCD_Command_Port &= ~(1<<RW);	/* RW=0 write operation */
	LCD_Command_Port |= (1<<EN);	/* Enable Pulse */
	_delay_us(1);
	LCD_Command_Port &= ~(1<<EN);
	_delay_ms(1);
}

void LCD_Init (void)			/* LCD Initialize function */
{
	LCD_Command_Dir = 0xFF;		/* Make LCD command port direction as o/p */
	LCD_Data_Dir = 0xFF;		/* Make LCD data port direction as o/p */
	_delay_ms(20);			/* LCD Power ON delay always >15ms */
	
	LCD_Command (0x38);		/* Initialization of 16X2 LCD in 8bit mode */
	LCD_Command (0x0C);		/* Display ON Cursor OFF */
	LCD_Command (0x06);		/* Auto Increment cursor */
	LCD_Command (0x01);		/* Clear display */
	LCD_Command (0x80);		/* Cursor at home position */
}

void LCD_String (char *str)		/* Send string to LCD function */
{
	int i;
	for(i=0;str[i]!=0;i++)		/* Send each char of string till the NULL */
	{
		LCD_Char (str[i]);
	}
}

void LCD_String_xy (char row, char pos, char *str)/* Send string to LCD with xy position */
{
	if (row == 0 && pos<16)
	LCD_Command((pos & 0x0F)|0x80);	/* Command of first row and required position<16 */
	else if (row == 1 && pos<16)
	LCD_Command((pos & 0x0F)|0xC0);	/* Command of first row and required position<16 */
	LCD_String(str);		/* Call LCD string function */
}

void LCD_Clear()
{
	LCD_Command (0x01);		/* clear display */
	LCD_Command (0x80);		/* cursor at home position */
}

void wls_print()
{
	unsigned char c[5];
	read_wls();
	itoa(wls_left, c, 10);
	LCD_String(c);
	
	itoa(wls_middle, c, 10);
	LCD_String_xy(0,5,c);
	
	itoa(wls_right, c, 10);
	LCD_String_xy(1,0,c);
	_delay_ms(10);
}


////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                             ALGO PART
///////////////////////////////////////////////////////////////////////////////////////////////////////////////
int CM_place_in_bot[4]={0,0,0,0};
int high_or_low[5]={0,1,1,0,0};
int mat_req_for_house[5]={2,2,2,2,2};
int mat_remain[6]={1,1,1,1,1,1};
 int or_path[17]={0,0,0,0,11};
 int dup_path[12];
 
 bool isSelected=FALSE;
 int mat_picked[]={2,2};
 int Dist[12][12]={  {0, 5, 2, 5, 4, 7, 1, 4, 3, 6, 7,  3},//1
 {5, 0, 5, 2, 7, 4, 4, 1, 6, 3, 7,  3},//2
 {2, 5, 0, 5, 2, 7, 1, 4, 1, 6, 5,  5},//3
 {5, 2, 5, 0, 7, 2, 4, 1, 6, 1, 5,  5},//4
 {4, 7, 2, 7, 0, 6, 3, 6, 1, 6, 3,  7},//5
 {7, 4, 7, 2, 6, 0, 6, 3, 6, 1, 3,  7},//6
 {1, 4, 1, 4, 3, 6, 0, 3, 2, 7, 6,  4},//h1 7
 {4, 1, 4, 1, 6, 3, 3, 0, 7, 2, 6,  4},//h2 8
 {3, 6, 1, 6, 1, 6, 2, 7, 0, 5, 4,  6},//h3 9
 {6, 3, 6, 1, 6, 1, 7, 2, 5, 0, 4,  6},//h4 10
 {7, 7, 5, 5, 3, 3, 6, 6, 4, 4, 0, 10},//h5 11
 {3, 3, 5, 5, 7, 7, 4, 4, 6, 6, 10, 0},//start
 };
 
 int house[]={5,1,2,3,4};
 int CM[] = {5,6,2,3,6,4,1,2,4,1};
 struct available_mat
 {
	 int mat;
	 struct available_mat *next;
 };



int calculate_dist(int mat1,int mat2,int prev_H,int now_H)
{
	if(mat1==0 || mat2==0)
	{
		if(mat1!=0)
		return Dist[prev_H+5][mat1-1]+Dist[mat1-1][now_H+5];
		else if(mat2!=0)
		return Dist[prev_H+5][mat2-1]+Dist[mat2-1][now_H+5];
		else
		return Dist[prev_H+5][now_H+5];
	}
	else
	{
		if(Dist[prev_H+5][mat1-1]<Dist[prev_H+5][mat2-1])
		return Dist[prev_H+5][mat1-1]+Dist[mat1-1][mat2-1]+Dist[mat2-1][now_H+5];
		else
		return Dist[mat2-1][prev_H+5]+Dist[mat1-1][mat2-1]+Dist[now_H+5][mat1-1];
	}
}


 void decide_which_mat_take(struct available_mat* prev,struct available_mat* now,int bot_mat[],int H, int *b)
 {
	 int a=2;
	 
	 
	 struct available_mat *p,*q,*s1,*s2,*temp;
	 
	 bool CM1=TRUE;
	 bool CM2=TRUE;
	 s1=now;
	 s2=prev;
	 int mat_for_house_H[] = {CM[2*H-1],CM[2*H-2]};
	 
	 unsigned char c[10];
	 
	 //check bot_mat with mat req for given house
	 if(bot_mat[0]==mat_for_house_H[0] && CM1)
	 {
		 
		 CM1=FALSE;
		 a--;
	 }
	 else if(bot_mat[0]==mat_for_house_H[1] && CM2)
	 {
		 
		 CM2=FALSE;
		 a--;
	 }
	 if(bot_mat[1]==mat_for_house_H[0] && CM1)
	 {
		 
		 CM1=FALSE;
		 a--;
	 }
	 else if(bot_mat[1]==mat_for_house_H[1] && CM2)
	 {
		 
		 CM2=FALSE;
		 a--;
	 }
	 if(!CM1 && a==1)
	 {
		 q=malloc(sizeof(struct available_mat));
		 now->mat=mat_for_house_H[1];
		 
		 now->next=q;
		 now=q;
	 }
	 else if(!CM2 && a==1)
	 {
		 q=malloc(sizeof(struct available_mat));
		 now->mat=mat_for_house_H[0];
		 
		 now->next=q;
		 now=q;
	 }
	 bool ismat1=FALSE;
	 bool ismat2=FALSE;
	 bool for_H=FALSE;
	 *b=a;
	 int i=0;
	 while(prev!=NULL)
	 {
		 
		 //if mat in bot is mat req for house
		 if(a==0)
		 
		 {
			 
			 if((prev->mat!=mat_picked[0] || ismat1) && (prev->mat!=mat_picked[1] || ismat2) )
			 {
				 q=malloc(sizeof(struct available_mat));
				 now->mat=prev->mat;
				 
				 
				 now->next=q;
				 temp=now;
				 now=q;
			 }
			 else
			 {
				 if(prev->mat==mat_picked[0])
				 ismat1=TRUE;
				 else if(prev->mat==mat_picked[1])
				 ismat2=TRUE;
			 }
			 
			 prev=prev->next;
		 }
		 
		 else if(a==1)
		 {
			 if(!CM1)
			 {
				 
				 if(((prev->mat!=mat_picked[0] || ismat1) && (prev->mat!=mat_picked[1] || ismat2) )&& (prev->mat!=mat_for_house_H[1] || for_H) )
				 {
					 q=malloc(sizeof(struct available_mat));
					 now->mat=prev->mat;
					 
					 now->next=q;
					 temp=now;
					 now=q;
				 }
				 else
				 {
					 if(prev->mat==mat_picked[0])
					 ismat1=TRUE;
					 else if(prev->mat==mat_picked[1])
					 ismat2=TRUE;
					 else if(prev->mat==mat_for_house_H[1])
					 for_H=TRUE;
				 }
				 
				 prev=prev->next;
				 
			 }
			 else if(!CM2)
			 {
				 
				 if(((prev->mat!=mat_picked[0] || ismat1) && (prev->mat!=mat_picked[1] || ismat2) )&& (prev->mat!=mat_for_house_H[0] || for_H))
				 {
					 q=malloc(sizeof(struct available_mat));
					 now->mat=prev->mat;
					 
					 now->next=q;
					 temp=now;
					 now=q;
				 }
				 else
				 {
					 if(prev->mat==mat_picked[0])
					 ismat1=TRUE;
					 else if(prev->mat==mat_picked[1])
					 ismat2=TRUE;
					 else if(prev->mat==mat_for_house_H[0])
					 for_H=TRUE;
				 }
				 
				 prev=prev->next;
			 }
		 }
		 //mat req for house is not in bot hence take those material only
		 else if(a==2)
		 {
			 unsigned char c[10];
			 
			 prev=NULL;
			 q=malloc(sizeof(struct available_mat));
			 
			 
			 now->mat=mat_for_house_H[0];
			 
			 now->next=q;
			 now=q;
			 now->mat=mat_for_house_H[1];
			 
			 
		 }
	 }
	 if(a!=2)
	 {
		 now=temp;
		 free(q);
	 }
	 now->next=NULL;
	 now=s1;
	 prev=s2;
	 
	 
 }


 void swap(int *x, int *y)
 {
	 int temp;
	 temp = *x;
	 *x = *y;
	 *y = temp;
 }


 int max_distance= 99;

 ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
 //                              CM_pick_order
 ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  
  void CM_pick_order(int step,int comb_of_HOUSE[5],struct available_mat* prev,int mat_in_bot[],int distance_upto_now)
  {

	  step++;
	  if(step==4)
	  {

		  int distance=distance_upto_now+Dist[comb_of_HOUSE[step-1]+6][comb_of_HOUSE[step]+6];
		  
		  if(distance<max_distance)
		  {
			  for(int i=0;i<9;i++)
			  or_path[i+5]=dup_path[i];
			  
			  
			  max_distance=distance;
			  or_path[3*(step-1)+5]=comb_of_HOUSE[step]+6;
			  or_path[3*(step-1)+1+5]=0;
			  or_path[3*(step-1)+2+5]=0;
			  
			  
		  }
	  }
	  else if(step!=4)
	  {
		  
		  
		  // 		 int new_mat_in_bot[2];
		  // 		 new_mat_in_bot[0]=mat_in_bot[0];
		  // 		 new_mat_in_bot[1]=mat_in_bot[1];
		  int prev_m1=mat_picked[0];
		  int prev_m2=mat_picked[1];
		  
		  struct available_mat *now,*dup_now,*availmat,*dup_availmat,*head,*comb1,*comb2,*q,*for_availmat,*for_prev,*for_c1,*for_c2;
		  int a;
		  now = malloc(sizeof(struct available_mat));
		  dup_now=now;
		  availmat=malloc(sizeof(struct available_mat));
		  dup_availmat=availmat;
		  
		  //see available combination of available_materials
		  decide_which_mat_take(prev, now, mat_in_bot, comb_of_HOUSE[step], &a);
		  
		  //this will be used for generating combination of materials
		  comb1=now;
		  comb2=now->next;
		  
		  //now combination of available materials
		  
		  head=availmat;
		  for_prev=prev;
		  bool ismat1=FALSE;
		  bool ismat2=FALSE;
		  bool CM1=FALSE;
		  bool CM2=FALSE;
		  bool isQ=FALSE;
		  for_availmat=availmat;
		  while(prev!=NULL)
		  {
			  //making list for next available material
			  if((prev->mat!=mat_picked[0] || ismat1) && (prev->mat!=mat_picked[1] || ismat2)  )
			  {
				  isQ=TRUE;
				  q=malloc(sizeof(struct available_mat));
				  availmat->mat=prev->mat;
				  for_availmat=availmat;
				  
				  availmat->next=q;
				  availmat=q;
			  }
			  else
			  {
				  if(prev->mat==mat_picked[0])
				  ismat1=TRUE;
				  else if(prev->mat=mat_picked[1])
				  ismat2=TRUE;
			  }
			  
			  prev=prev->next;
		  }
		  if(isQ)
		  free(q);
		  
		  availmat=for_availmat;
		  
		  availmat->next=NULL;
		  availmat=head;
		  prev=for_prev;
		  
		  int distance;
		  //begin the combination of available_materials
		  
		  if(a==0)
		  {
			  while(comb1->next!=NULL)
			  {
				  while(comb2!=NULL)
				  {
					  
					  distance=distance_upto_now+calculate_dist(comb2->mat,comb1->mat,comb_of_HOUSE[step-1],comb_of_HOUSE[step]);
					  if(distance<max_distance)
					  {
						  
						  mat_in_bot[0]=comb2->mat;
						  mat_in_bot[1]=comb1->mat;
						  if(Dist[comb_of_HOUSE[step-1]][comb1->mat]<Dist[comb_of_HOUSE[step-1]][comb2->mat])
						  {
							  dup_path[3*(step-1)]=comb1->mat;
							  dup_path[3*(step-1)+1]=comb2->mat;
						  }
						  else
						  {
							  dup_path[3*(step-1)]=comb2->mat;
							  dup_path[3*(step-1)+1]=comb1->mat;
						  }
						  dup_path[3*(step-1)+2]=comb_of_HOUSE[step]+6;
						  int M1=mat_picked[0];
						  int M2=mat_picked[1];
						  mat_picked[0]=comb1->mat;
						  mat_picked[1]=comb2->mat;
						  
						  CM_pick_order(step, comb_of_HOUSE, availmat, mat_in_bot, distance);
						  
						  mat_picked[0]=M1;
						  mat_picked[1]=M2;
						  
						  
					  }
					  
					  comb2=comb2->next;
				  }
				  
				  comb1=comb1->next;
				  comb2=comb1->next;
			  }
		  }
		  else if(a==1)
		  {
			  
			  while(comb2!=NULL)
			  {
				  
				  distance=distance_upto_now+calculate_dist(comb2->mat,comb1->mat,comb_of_HOUSE[step-1],comb_of_HOUSE[step]);
				  
				  if(distance<max_distance)
				  {
					  for(int i=0;i<2;i++)
					  {
						  if(mat_in_bot[i]==CM[2*comb_of_HOUSE[step]-1] ||  mat_in_bot[i]==CM[2*comb_of_HOUSE[step]-2] )
						  {
							  
							  mat_in_bot[i]=comb2->mat;
							  break;
						  }
					  }
					  
					  if(Dist[comb_of_HOUSE[step-1]][comb1->mat]<Dist[comb_of_HOUSE[step-1]][comb2->mat])
					  {
						  dup_path[3*(step-1)]=comb1->mat;
						  dup_path[3*(step-1)+1]=comb2->mat;
					  }
					  else
					  {
						  dup_path[3*(step-1)]=comb2->mat;
						  dup_path[3*(step-1)+1]=comb1->mat;
					  }
					  dup_path[3*(step-1)+2]=comb_of_HOUSE[step]+6;
					  int M1=mat_picked[0];
					  int M2=mat_picked[1];
					  mat_picked[0]=comb1->mat;
					  mat_picked[1]=comb2->mat;
					  
					  CM_pick_order(step, comb_of_HOUSE, availmat, mat_in_bot, distance);
					  
					  // 					 new_mat_in_bot[0]=mat_in_bot[0];
					  // 					 new_mat_in_bot[1]=mat_in_bot[1];
					  mat_picked[0]=M1;
					  mat_picked[1]=M2;
					  
				  }
				  comb2=comb2->next;
			  }
			  //free(comb1);
			  
		  }
		  else if(a==2)
		  {
			  
			  
			  distance=distance_upto_now+calculate_dist(comb2->mat,comb1->mat,comb_of_HOUSE[step-1],comb_of_HOUSE[step]);
			  
			  if(distance<max_distance)
			  {
				  
				  
				  if(Dist[comb_of_HOUSE[step-1]][comb1->mat]<Dist[comb_of_HOUSE[step-1]][comb2->mat])
				  {
					  dup_path[3*(step-1)]=comb1->mat;
					  dup_path[3*(step-1)+1]=comb2->mat;
				  }
				  else
				  {
					  dup_path[3*(step-1)]=comb2->mat;
					  dup_path[3*(step-1)+1]=comb1->mat;
				  }
				  
				  dup_path[3*(step-1)+2]=comb_of_HOUSE[step]+6;
				  
				  int M1=mat_picked[0];
				  int M2=mat_picked[1];
				  mat_picked[0]=comb1->mat;
				  mat_picked[1]=comb2->mat;
				  
				  CM_pick_order(step, comb_of_HOUSE, availmat, mat_in_bot, distance);
				  mat_picked[0]=M1;
				  mat_picked[1]=M2;
				  
			  }
		  }
		  
		  delete_list(dup_now);
		  delete_list(dup_availmat);
		  
		  // free(&a);
		  mat_picked[0]=prev_m1;
		  mat_picked[1]=prev_m2;
		  //free(comb1);
		  //free(comb2);
	  }
	  
	  
  }

 void delete_list(struct available_mat *head)
 {
	 struct available_mat *temp;
	 while(head->next!=NULL)
	 {
		 temp=head;
		 head=head->next;
		 free(temp);
	 }
	 free(head);
 }

void permute(int *a, int l, int r,struct available_mat* prev,int flag)   // (*f)(int ,int ,int ,int ,int) https://medium.com/@jraleman/c-programming-language-passing-a-function-as-a-parameter-90d52fe842ea
{
	int i;
	if (l == r)
	{
		if(flag==0)
		{
			int start = 11;
			int H5 = 10;

			int distance = Dist[start][a[0]-1]+Dist[a[0]-1][a[1]-1]+Dist[a[1]-1][a[2]-1]+Dist[a[2]-1][a[3]-1]+Dist[a[3]-1][H5];
			if(distance<max_distance)
			{
				
				for(i=0;i<4;i++)
					or_path[i]=a[i];
				
				
				isSelected=TRUE;
				max_distance=distance;
				
			}
			
		}
		else
		{
			
			int a = mat_picked[0];
			int b = mat_picked[1];
			int bot_mat[] = {mat_picked[0],mat_picked[1]};
			int distance=0;
			int step = 0;
			
			mat_picked[0]=bot_mat[0];
			mat_picked[1]=bot_mat[1];
			CM_pick_order(step,house,prev,bot_mat,distance);
			
			mat_picked[0]=a;
			mat_picked[1]=b;
		}
	}

	else
	{
		for (i = l; i <= r; i++)
		{
			swap((a+l), (a+i));
			permute(a, l+1, r,prev,flag);
			swap((a+l), (a+i)); //backtrack
		}
	}
}

void decide_CM_for_H5()
{
	int H5_mat_array[4]={CM[8],CM[9],0,0};
	for(int i=0;i<6;i++)
	{
		if(CM[i]!=0)
		{
			for(int j=i+1; j<7;j++)
			{
				if(CM[j]!=0)
				{
					H5_mat_array[2]=CM[i];
					H5_mat_array[3]=CM[j];
					struct available_mat* dummy;
					permute(H5_mat_array,0,3,dummy,0);
					if(isSelected)
					{
						mat_picked[0]=CM[i];
						mat_picked[1]=CM[j];
					}
					isSelected=FALSE;
				}
			}
		}
	}
	max_distance=999;
}

void make_path()
{
	struct available_mat *head,*p,*prev,*q;
	// copying CM from array to linked list
	head=malloc(sizeof(struct available_mat));
	head->mat=CM[0];
	head->next=NULL;
	p=head;
	prev=head;
	for(int i=1;i<8;i++)
	{
		q=malloc(sizeof(struct available_mat));
		p->next=q;
		q->mat=CM[i];
		
		if(i<8)
		p=q;
		else
		p->next=NULL;
	}
	decide_CM_for_H5();
	permute(house, 1, 4,prev,1);
	delete_list(head);
}
 /////////////////////////////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


/*
*Team Id: 1634
*Author List: Praveen Dwivedi,Praveen kumar Yadav,Darshan ,Gosu Arun kumar
*Filename: CB_Task_1_Sandbox.cpp
*Theme: Construct-O-Bot – eYRC Specific
*Functions: next_move(char), all_sensor_black(), all_sensor_white(), get_back_to_line(), isNode(), follow_white_line(), forward_wls(char), left_turn_wls(), right_turn_wls(), Task_1_1()
*Global Variables: NONE
*/

//  #verified but function description is remaining
void shortest_path(int u,int l)
{
		int i,j,n;
		n=16;
		int G[16][16]={{0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,1},
		{2,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0},
		{0,2,0,1,0,0,0,0,0,0,0,0,0,0,0,0},
		{0,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0},
		{0,0,0,1,0,1,0,0,0,0,0,0,0,0,4,0},
		{0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0},
		{0,0,0,0,0,1,0,1,0,0,0,0,5,0,0,0},
		{0,0,0,0,0,0,1,0,1,0,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,1,0,2,0,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,2,0,2,0,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,2,0,1,0,0,0,0},
		{0,0,0,0,0,0,0,0,0,0,1,0,1,0,0,0},
		{0,0,0,0,0,0,5,0,0,0,0,1,0,1,0,0},
		{0,0,0,0,0,0,0,0,0,0,0,0,1,0,1,0},
		{0,0,0,0,4,0,0,0,0,0,0,0,0,1,0,1},
		{1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0}};
		

		if(u==l)
		{LCD_Clear();
			LCD_String("same");
			_delay_ms(1000);
			LCD_Clear();
		}
		else
		{
			dijkstra(G,n,u,l);
			
			for(int i=0;i<count1;i++)
			{
				//printf("%d>>%d",path[step][i],path[step][i+1]);
				travel(path[step][i],path[step][i+1]);
			}
		}
		return 0;
}

/*
*Team Id: 1634
*Author List: Praveen Dwivedi,Praveen kumar Yadav,Darshan ,Gosu Arun kumar
*Filename: CB_Task_1_Sandbox.cpp
*Theme: Construct-O-Bot – eYRC Specific
*Functions: next_move(char), all_sensor_black(), all_sensor_white(), get_back_to_line(), isNode(), follow_white_line(), forward_wls(char), left_turn_wls(), right_turn_wls(), Task_1_1()
*Global Variables: NONE
*/

//  #verified but function description is remaining
void dijkstra(int G[MAX][MAX],int n,int startnode,int lastnode)
{
	int cost[MAX][MAX],distance[MAX],pred[MAX];
	int visited[MAX],count,mindistance,nextnode,i,j;
	//pred[] stores the predecessor of each node
	//count gives the number of nodes seen so far
	//create the cost matrix
	for(i=0;i<n;i++)
	for(j=0;j<n;j++)
	if(G[i][j]==0)
	cost[i][j]=INFINITY;
	else
	cost[i][j]=G[i][j];
	
	//initialize pred[],distance[] and visited[]
	for(i=0;i<n;i++)
	{
		distance[i]=cost[startnode][i];
		pred[i]=startnode;
		visited[i]=0;
	}
	
	distance[startnode]=0;
	visited[startnode]=1;
	count=1;
	
	while(count<n-1)
	{
		mindistance=INFINITY;
		
		//nextnode gives the node at minimum distance
		for(i=0;i<n;i++)
		if(distance[i]<mindistance&&!visited[i])
		{
			mindistance=distance[i];
			nextnode=i;
		}
		
		//check if a better path exists through nextnode
		visited[nextnode]=1;
		for(i=0;i<n;i++)
		if(!visited[i])
		if(mindistance+cost[nextnode][i]<distance[i])
		{
			distance[i]=mindistance+cost[nextnode][i];
			pred[i]=nextnode;
		}
		count++;
	}
	
	
	//print the path and distance of each node
	i=lastnode;
	if(i!=startnode)
	{
		printf("\nDistance of node%d=%d",i,distance[i]);
		//printf("\nPath=%d",i);
		
		j=i;
		count1=0;
		// 			int c[20];
		// 			int l=0;
		do
		{
			j=pred[j];
			//printf("<-%d",j);
			count1++;
		}while(j!=startnode);
		j=i;
		path[step][count1]=lastnode;
		//printf("\nnodes = %d\n",count1);
		for(int i=0;i<count1;i++)
		{
			path[step][count1-i-1]=pred[j];
			//printf("%d ",pred[j]);
			j=pred[j];
		}
		for(int i=0;i<count1+1;i++)
		{
			
			printf("\n%d ",path[step][i]);
			
		}
	}	
}


/*
*
* Function Name: all_sensor_black
* Input: void
* Output: void
* Logic: Uses white line sensors to detect white line
* Example Call: all_sensor_black(); //Moves right & left alternatively repeatedly until white line is detected
*
*/
void travel(int p1, int p2)
{
	
	if (direction == clk)
	{
		if (( (p1==4 && p2==3)||(p1==6 && p2==5)||(p1==12 && p2==11)||(p1==14 && p2==13)  )&& (f==1))
		{
			right_turn_wls();

			//printf("right a and flag = %d\t", f);
			f = 0;
			direction=clk;
		}
		else if (( (p1==4 && p2==5)||(p1==6 && p2==7)||(p1==12 && p2==13)||(p1==14 && p2==15)  )&&(f==1))
		{
			left_turn_wls();
			//printf("left \n");
			f = 0;
			direction=anclk;
		}
		else if (p1 == 10 || p1 == 8 || p1 == 2 || p1 == 0)
		{

			right_turn_wls();
			//printf("right b\n");
		}
		else if(p2-p1==1)
		{
			//printf("turn_180");
			direction=anclk;
			turn_180();
		}
		else if (abs(p1 - p2) > 1)
		{
			right_turn_wls();
			//printf("right c\n");
			f=1;
			
		}
		
	}
	else if (direction == anclk)
	{
		//printf("\np1:%d\n", p1);
		//printf("f:%d\n", f);
		if (( (p1==4 && p2==5)||(p1==6 && p2==7)||(p1==12 && p2==13)||(p1==14 && p2==15)  )&&(f==1))
		{
			left_turn_wls();
			//printf("left \n");
			f = 0;
			direction=anclk;
		}
		else if (( (p1==4 && p2==3)||(p1==6 && p2==5)||(p1==12 && p2==11)||(p1==14 && p2==13)  )&&(f==1))
		{
			right_turn_wls();

			//printf("right a and flag = %d\t", f);
			f = 0;
			direction=clk;
		}
		else if (p1 == 10 || p1 == 8 || p1 == 2 || p1 == 0)
		{
			left_turn_wls();
			//printf("left \n");
		}
		else if(p1-p2==1)
		{
			//printf("turn_180\n");
			direction=clk;
			turn_180();
		}
		else if (abs(p1 - p2) > 1 && p2!=0)
		{
			left_turn_wls();
			//printf("left \n");
			f = 1;
		}
		
	}
	if ((p1 == 14 && p2 == 4) || (p1 == 4 && p2 == 14))
	{
		//printf("wall follow \n");
		wall_follower();
	}
	else if((p1 == 12 && p2 == 6) || (p1 == 6 && p2 == 12))
	{
		forward_wls_zz(1,150);
	}
	else if (( p1 == 8 && p2 == 9)||( p1 == 9 && p2 == 10)|| (p1 == 10 && p2 == 9)|| (p1 == 9 && p2 == 8))
	{
		//printf("whiteline follow\n");
		follow_white_line(1,150,p1);
	}
	else if (p2 == 9)
	{
		//printf("forward_wls\n");
		forward_wls(1, 150);
	}
	else if((p1==7 && p2==8) || (p1==10 && p2==11) )
	{
		forward_wls(1,130);
	}
	else
	{
		//printf(" forward\n");
		forward_wls(1, 150);
	}
	//printf("%d \n", direction);

	//	_delay_ms(20);


}
bool isWhite_node()
{
	while(1)
	{
		read_wls();
		if(wls_left>100 && wls_middle<100 && wls_right>100)
			turn_right();
		else if(wls_left<100 && wls_middle<100 && wls_right<100)
			turn_left();
		else if(wls_left<100 && wls_middle<100 && wls_right<100)
			return TRUE;
		else
			return FALSE;
	}
	
}
void follow_white_line(int node,int speed,int point)
{
	if(point==9)
	{
// 		read_wls();
// 		
// 		//in white node
// 		while (wls_middle < 100 && (wls_left < 100 || wls_right < 100))
// 		{
// 			velocity(150,132);
// 			forward();
// 			read_wls();
// 			
// 			
// 		}
// 		velocity(150,135);
// 		forward();
		while (1)
		{
			read_wls();
			
			
			
			//NODE DETECTED
			//all white
			if (wls_middle < 150 && wls_left < 150 && wls_right < 150)
			{
				all_sensor_white();
				read_wls();
				
					forward_wls(1,150);
					break;
				
				
			}
			
			else if (wls_middle < 150 && (wls_left < 150 || wls_right < 150))
			{
				velocity(120,120);
				
				
				if(wls_left < 150)
				turn_left();
				else if (wls_right < 150)
				turn_right();
				_delay_ms(5);
				stopmm();
				
				
				
			}
			
			
			else if (wls_middle > 150 && (wls_left < 150 || wls_right< 150))
			{
				velocity(120,120);
				if(wls_middle>150 && wls_left<150 && wls_right<150)
				{
				  forward_wls(1,250);
				  break;
				}
				
				else if(wls_left < 150)
				{
					soft_left();
					_delay_ms(25);
				}
				else if(wls_right < 150)
				{
					soft_right();
					_delay_ms(25);
				}
			}
			//else if(wls_middle > 150 && wls_left < 100 && wls_right > 150)
// 			else if(wls_middle>150 && wls_left>150 && wls_right>150)
// 			{
// 			    forward_wls(1,250);
// 				break;
// 			}
			else
			{
				velocity(150,132);
				forward();
			}
			
			

		}
		wls_print();
		_delay_ms(5000);
	}
	
	
	
	
	//if point is 8 or 10
	
	else
	{
		
		stopmm();
		read_wls();
		wls_print();
		_delay_ms(1000);
		stopmm();
		while(wls_middle>100)
		{
			read_wls();
			if(point==10)
				soft_right();
			else
				soft_left();
			if(wls_middle<150)
			{
				stopmm();
				break;	
			}
			
			
		}
		stopmm();
		wls_print();
		_delay_ms(1000);
		while (1)
		{
			read_wls();
			
			
			
			//NODE DETECTED
			//all white
			if (wls_middle < 150 && wls_left < 150 && wls_right < 150)
				break;
				
			
			
			else if (wls_middle < 150 && (wls_left < 150 || wls_right < 150))
			{
				velocity(120,120);
				if(isWhite_node)
					break;
				
				else
				{
				
					if(wls_left < 150)
					turn_left();
					else if (wls_right < 150)
					turn_right();
					_delay_ms(5);
					stopmm();
				}
				
				
			}
			
			
			else if (wls_middle > 150 && (wls_left > 150 || wls_right> 150))
			{
				velocity(120,120);
				
				
				 if(wls_left < 150)
				{
					soft_left();
					_delay_ms(25);
				}
				else if(wls_right < 150)
				{
					soft_right();
					_delay_ms(25);
				}
			}
			//else if(wls_middle > 150 && wls_left < 100 && wls_right > 150)
			else if (wls_middle > 150 && wls_left > 150 && wls_right> 150)
			{
				stopmm();
			}
			else
			{
				velocity(150,132);
				forward();
			}
			
		}
  		left=0;
  		right=0;
  		while(left<250 && right<250)
  		{
  			velocity(150,132);
  			forward();
  		}
 		stopmm();
		_delay_ms(1000);
		wls_print();
		_delay_ms(1000);
		while(wls_middle>100)
		{
			if(wls_left<70 )
			turn_left();
			else if(wls_right<70 )
			turn_right();
			_delay_ms(10);
			read_wls();
		}
		stopmm();
	}

}

void all_sensor_white()
{
	stopmm();
	_delay_ms(100);
	int time_passed = 0;
	int max_time = 1;
	int i = 0;
	//unsigned char new_state = 'l';
	velocity(110,110);



	while (wls_middle <50)
	{
		max_time *= 4;
		if (new_state == 'r')
		{
			while ((time_passed < max_time) && (wls_middle <50))
			{

				turn_left();
				_delay_ms(100);
				stopmm();
				_delay_ms(15);
				time_passed++;
				read_wls();
			}
			stopmm();
			_delay_ms(10);
			time_passed = 0;
			read_wls();
			if (wls_middle >100)
			{
				break;
			}
			new_state = 'l';
			continue;
		}


		if (new_state == 'l')
		{
			while ((time_passed < max_time) && (wls_middle <50))
			{
				

				turn_right();
				_delay_ms(100);
				stopmm();
				_delay_ms(15);
				time_passed++;
				read_wls();
			}
			stopmm();
			_delay_ms(10);
			time_passed = 0;
			read_wls();

			if (wls_middle >100)
			{
				break;
			}
			new_state = 'r';

		}

	}

	stopmm();
	_delay_ms(100);
}


void forward_wls(int node,int speed)
{
	int i=0,node_covered=0;
	read_wls();
	while (wls_middle > 100 && wls_left > 100 && wls_right > 100)
	{
		velocity(speed,speed*135/150);
		forward();
		read_wls();
		
	}
	velocity(speed,speed*135/150);
	forward();
	while (1)
	{
		read_wls();
		
		
		
		//NODE DETECTED
		if (wls_middle > 100 && wls_left > 100 && wls_right > 100)
		{
			velocity(speed,speed*135/150);
			backward();
			_delay_ms(30);
			stopmm();
			_delay_ms(20);
			node_covered++;
			i=0;
			
			
			if (node_covered == node)
			{
				break;
			}
			
			
			while (wls_middle > 100 && wls_left > 100 && wls_right > 100)
			{
				velocity(speed,speed*135/150);
				forward();
				_delay_ms(30);
				read_wls();
			}
			
			stopmm();
			_delay_ms(250);
		}
		else if (wls_middle > 100 && (wls_left > 100 || wls_right > 100))
		{
			velocity(120,120);
			if(i==3)
			{
				backward();
				_delay_ms(15);
			}
			
			if(wls_left < 100)
			turn_right();
			else if (wls_right < 100)
			turn_left();
			_delay_ms(5);
			stopmm();
			i++;
			
			
		}
		
		
		else if (wls_middle < 100 && (wls_left > 100 || wls_right> 100))
		{
			
			
			velocity(120,120);
			if(wls_left > 100)
			{
				soft_left();
				_delay_ms(50);
			}
			else if(wls_right > 100)
			{
				soft_right();
				_delay_ms(50);
			}
		}
		//else if(wls_middle > 150 && wls_left < 100 && wls_right > 150)
		else
		{
			velocity(speed,speed*135/150);
			forward();
		}
		
		

	}
}

void line_follower()
{
	int i=0,node_covered=0;
	read_wls();
	velocity(150,135);
	forward();
	while (1)
	{
		read_wls();
		
		
		if (wls_middle < 30 && wls_left < 30 && wls_right < 30)
		{
			ir();
			if(ir_left<80)
			{
				forward();
				_delay_ms(10);
				continue;
			}
				
			velocity(150,132);
			stopmm();
			soft_left();
			_delay_ms(270);
			break;
		}
		else if (wls_middle > 100 && (wls_left > 100 || wls_right > 100))
		{
			velocity(120,120);
			if(i==3)
			{
				backward();
				_delay_ms(15);
			}
			
			if(wls_left < 100)
			turn_right();
			else if (wls_right < 100)
			turn_left();
			_delay_ms(5);
			stopmm();
			i++;
			
			
		}
		
		
		else if (wls_middle < 100 && (wls_left > 100 || wls_right> 100))
		{
			
			
			velocity(120,120);
			if(wls_left > 100)
			{
				soft_left();
				_delay_ms(50);
			}
			else if(wls_right > 100)
			{
				soft_right();
				_delay_ms(50);
			}
		}
		else
		{
			velocity(150,132);
			forward();
		}
		
		

	}
}




void forward_wls_zz(int node,int speed)
{
	int i=0,node_covered=0;
	read_wls();
	while (wls_middle > 100 && wls_left > 100 && wls_right > 100)
	{
		velocity(150,132);
		forward();
		read_wls();
		
	}
	velocity(150,135);
	forward();
	while (1)
	{
		read_wls();
		
		
		if (wls_middle < 50 && wls_left < 50 && wls_right < 50)
		{
			all_sensor_white();
		}
		//NODE DETECTED
		else if (wls_middle > 100 && wls_left > 100 && wls_right > 100)
		{
			velocity(150,132);
			backward();
			_delay_ms(30);
			stopmm();
			_delay_ms(20);
			node_covered++;
			i=0;
			
			
			if (node_covered == node)
			{
				break;
			}
			
			
			while (wls_middle > 100 && wls_left > 100 && wls_right > 100)
			{
				velocity(150, 132);
				forward();
				_delay_ms(30);
				read_wls();
			}
			
			stopmm();
			_delay_ms(250);
		}
		else if (wls_middle > 100 && (wls_left > 100 || wls_right > 100))
		{
			velocity(120,120);
			if(i==3)
			{
				backward();
				_delay_ms(15);
			}
			
			if(wls_left < 100)
			turn_right();
			else if (wls_right < 100)
			turn_left();
			_delay_ms(5);
			stopmm();
			i++;
			
			
		}
		
		
		else if (wls_middle < 100 && (wls_left > 100 || wls_right> 100))
		{
			
			
			velocity(120,120);
			if(wls_left > 100)
			{
				soft_left();
				_delay_ms(50);
			}
			else if(wls_right > 100)
			{
				soft_right();
				_delay_ms(50);
			}
		}
		//else if(wls_middle > 150 && wls_left < 100 && wls_right > 150)
		else
		{
			velocity(150,132);
			forward();
		}
		
		

	}
}

void left_turn_wls(void)
{
	
	
	velocity(120,120);
	forward();
	_delay_ms(200);
	soft_left();
	_delay_ms(250);
	read_wls();
	while (wls_middle < 130)
	{
		velocity(110,110);
		soft_left();

		read_wls();

	}
	stopmm();
}
void right_turn_wls(void)
{
	velocity(120,120);
	forward();
	_delay_ms(200);
	soft_right();
	_delay_ms(250);
	read_wls();
	while (wls_middle < 130)
	{
		velocity(115,115);
		soft_right();

		read_wls();

	}
}


void buzzer()
{
	DDRD=0xF0;
	for(int i=0;i<2500;i++)       //5 seconds 25500
	{
		PORTD=0b10000000;
		_delay_us(100);
		PORTD=0b00000000;
		_delay_us(100);
	}
	DDRD=0x00;
	
}
void turn_180()
{
	forward();
	_delay_ms(700);
	velocity(120,120);
	turn_right();
	_delay_ms(1500);
	stopmm();
	read_wls();
	while(wls_middle<100)
	{
		velocity(100,100);
		turn_right();
		read_wls();
	}
	stopmm();
}

void servo0(int initial,int final)
{
	if(initial<=525 && final<=525)
	{
		servo01(initial,final);
	}
	else if(initial<=525 && final>525)
	{
		servo01(initial,525);
		servo00(97,final-525);
		
	}
	else if(initial>=525 && final<525)
	{
		servo00(initial-525,97);
		servo01(525,final);	
	}
	else if(initial>=525 && final>=525)
	{
		servo00(initial-525,final-525);
	}
}
void servo00(int initial,int final)
{
	if(initial<final)
	{
		for(int i=initial;i<=final;i++)
		{
			OCR3A = i;
			_delay_ms(5);
		}
	}
	else if(final<initial)
	{
		for(int i=initial;i>=final;i--)
		{
			OCR3A = i;
			_delay_ms(5);
		}
	}
}

void servo01(int initial,int final)
{
	if(initial<final)
	{
		for(int i=initial;i<=final;i++)
		{
			OCR3B = i;
			_delay_ms(5);
		}
	}
	else if(final<initial)
	{
		for(int i=initial;i>=final;i--)
		{
			OCR3B = i;
			_delay_ms(5);
		}
	}
	
}
void servo1(int initial,int final)
{
	if(initial<final)
	{
		for(int i=initial;i<=final;i++)
		{
			OCR4A = i;
			_delay_ms(10);
		}
	}
	else if(final<initial)
	{
		for(int i=initial;i>=final;i--)
		{
			OCR4A = i;
			_delay_ms(10);
		}
	}
	// {
	// 		for(int i=97;i<=260;i++)
	// 	{
	// 		OCR4A = i;
	// 		_delay_ms(10);
	// 	}
	// 		for(int i=260;i>=97;i--)
	//
	// 		{
	// 			OCR4A = i;
	// 			_delay_ms(10);
	// 		}
	
}
void servo2(int initial,int final)
{
	if(initial<final)
	{
		for(int i=initial;i<=final;i++)
		{
			OCR4B = i;
			_delay_ms(10);
		}
	}
	else if(final<initial)
	{
		for(int i=initial;i>=final;i--)
		{
			OCR4B = i;
			_delay_ms(10);
		}
	}
	// {
	// 	for(int i=50;i<=250;i++)
	// 	{
	// 		OCR4B = i;
	// 		_delay_ms(20);
	// 	}
	// 	for(int i=250;i>=50;i--)
	// 	{
	// 		OCR4B = i;
	// 		_delay_ms(20);
	// 	}
}
void servo3(int initial,int final)
{
	if(initial<final)
	{
		for(int i=initial;i<=final;i++)
		{
			OCR1B = i;
			_delay_ms(10);
		}
	}
	else if(final<initial)
	{
		for(int i=initial;i>=final;i--)
		{
			OCR1B = i;
			_delay_ms(10);
		}
	}
	// {
	// 	for(int i=40;i<=150;i++)
	// 	{
	// 		OCR1B = i;
	// 		_delay_ms(10);
	// 	}
	// 		for(int i=150;i>=40;i--)
	// 		{
	// 			OCR1B = i;
	// 			_delay_ms(10);
	// 		}
}
void servo4(int initial,int final)
{
	if(initial<final)
	{
		for(int i=initial;i<=final;i++)
		{
			OCR1A = i;
			_delay_ms(10);
		}
	}
	else if(final<initial)
	{
		for(int i=initial;i>=final;i--)
		{
			OCR1A = i;
			_delay_ms(10);
		}
	}
	// 	for(int i=160;i<=250;i++)
	// 	{
	// 		OCR1A = i;
	// 		_delay_ms(20);
	// 	}
	// 	for(int i=250;i>=160;i--)
	// 	{
	// 		OCR1A = i;
	// 		_delay_ms(20);
	// 	}
}


void velocity (unsigned char left_motor, unsigned char right_motor)
{
	OCR5AL = (unsigned char)left_motor;
	OCR5BL = (unsigned char)right_motor;
}

void read_wls(void)
{
	ADCSRA=0x87;
	ADCSRB=0x00;
	ADMUX=0xA0;
	ADMUX = 0xA0;
	ADCSRA |= (1 << ADEN);  // Enable ADC
	ADCSRA |= (1 << ADSC);  // Start A2D Conversions
	while(ADCSRA & (1<<ADSC)){}
	wls_left=ADCH;
	
	//Serial.print("A0: ");
	//Serial.println(ADCH);
	ADMUX = 0xA1;
	ADCSRA |= (1 << ADEN);  // Enable ADC
	ADCSRA |= (1 << ADSC);  // Start A2D Conversions
	while(ADCSRA & (1<<ADSC)){}
	wls_middle=ADCH;
	
	//Serial.print("A1: ");
	//	Serial.println(ADCH);
	ADMUX = 0xA2;
	ADCSRA |= (1 << ADEN);  // Enable ADC
	ADCSRA |= (1 << ADSC);  // Start A2D Conversions
	while(ADCSRA & (1<<ADSC)){}
	wls_right=ADCH;
	
	//Serial.print("A2: ");
	//Serial.println(ADCH);
	//      _delay_ms(100);
}

void stopmm()
{
	PORTD =0b00000000;
}
void forward()
{
	PORTD =0b00000101;
}
void backward()
{
	PORTD =0b00001010;
}
void turn_right()
{
	PORTD =0b00001001;
}
void turn_left()
{
	PORTD =0b00000110;
}
void soft_right()
{
	PORTD =0b00000001;
}
void soft_left()
{
	PORTD =0b00000100;
}
void pick_bot()
{
	//read_wls();
	//while(wls_middle<200)
	//{
	//if(wls_left>200 && wls_middle<200)
	//turn_left();
	//else if(wls_right>200 && wls_middle<200)
	//turn_right();
	//else if(wls_left>200)
	//turn_left();
	//else if(wls_right>200)
	//turn_right();
	//else
	//break;
	//_delay_ms(30);
	//read_wls();
	//}
	//stopmm();
	servo2(450,355);
	servo1(370,110);
	servo2(355,260);
	servo4(300,150);
	servo1(110,270);
	servo2(260,355);
	servo1(270,370);
	servo2(355,450);
}
void place_lr()
{
	servo2(450,326);
	servo1(370,206);
	servo4(150,300);
	servo1(206,270);
	servo2(326,355);
	servo1(270,370);
	servo2(355,450);
	
}
void place_hr()
{
	servo2(450,300);
	servo1(370,290);
	servo4(150,300);
	servo1(290,365);
	servo2(300,450);
	
	
}
void place_in(int d, int pi, int pl)                // pl=place position
{
	//pick 1,2,3,4-on the bot, 5-outside, 6-inside
	//place1,2,3,4-on the bot, 5-outside low rise, 6- outside high rise , 7-inside, 8-front low rise, 9-front high rise
	
	_delay_ms(100);
	int a;
	if(d==clk)
	{
		if(pi==5)
		a=316;
		else if(pi==6)
		a=850;
	}
	else if(d==anclk)
	{
		if(pi==5)
		a=850;
		else if(pi==6)
		a=316;
	}
	
	
	if(a==316)
	{
		if(pl==1)
		{
			servo2(450,420);
			servo0(a,780);
			//stepper(stepc,1800);
			servo2(420,450);
			servo3(316,370);
			servo1(370, 250);
			
			servo4(150, 300);
			servo1(250,370);
			servo3(370,316);
			//stepper(stepac,1000);
			servo0(780,97);
		}
		else if(pl==2)
		{
			servo2(450,420);
			servo0(a,1000);
			servo2(420,450);
			//stepper(stepc,1000);
			servo3(316,370);
			servo1(370, 250);
			
			servo4(150, 300);
			servo1(250,370);
			servo3(370,316);
			//stepper(stepac,200);
			servo0(1000,97);
		}
		else if(pl==3)
		{
			servo2(450,420);
			servo0(a,243);
			servo2(420,450);
			//stepper(stepc,200);
			servo3(316,370);
			servo1(370, 250);
			
			servo4(150, 300);
			servo1(250,370);
			servo3(370,316);
			servo0(243,97);
			//stepper(stepc,600);
		}
		else if(pl==4)
		{
			servo2(450,420);
			servo0(a,460);
			servo2(420,450);
			//stepper(stepac,200);
			servo3(316,370);
			servo1(370, 250);
			
			servo4(150, 300);
			servo1(250,370);
			servo3(370,316);
			servo0(460,97);
			//stepper(stepc,1000);
		}
		
	}
	else if(a==850)
	{
		if(pl==1)
		{
			servo2(450,420);
			servo0(a,780);
			servo2(420,450);
			/*stepper(stepc,200);*/
			servo3(316,370);
			servo1(370, 250);
			
			servo4(150, 300);
			servo1(250,370);
			servo3(370,316);
			servo0(780,97);
			//stepper(stepac,1000);
			
		}
		else if(pl==2)
		{
			servo2(450,420);
			servo0(a,1000);
			servo2(420,450);
			//stepper(stepac,600);
			servo3(316,370);
			servo1(370, 250);
			servo4(150, 300);
			servo1(250,370);
			servo3(370,316);
			servo0(1000,97);
			//stepper(stepac,200);
			
		}
		else if(pl==3)
		{
			servo2(450,420);
			servo0(a,243);
			servo2(420,450);
			//stepper(stepac,1400);
			servo3(316,370);
			servo1(370, 250);
			servo4(150, 300);
			servo1(250,370);
			servo3(370,316);
			servo0(243,97);
			//stepper(stepc,600);
		}
		else if(pl==4)
		{
			servo2(450,420);
			servo0(a,460);
			servo2(420,450);
			//stepper(stepac,2200);
			servo3(316,370);
			servo1(370, 250);
			servo4(150, 300);
			servo1(250,370);
			servo3(370,316);
			servo0(460,97);
			//stepper(stepc,1400);
		}
	}
}
void pick_from(int d, int a, int p)
{//pick 1,2,3,4-on the bot, 5-outside, 6-inside
	//place1,2,3,4-on the bot, 5-outside low rise, 6- outside high rise , 7-inside, 8-front low rise, 9-front high rise
	switch(a)
	{
		case 1:
		{
			servo2(450,420);
			//stepper(stepc, 1000);
			
			servo0(97,780);
			servo2(420,450);
			servo3(316,370);
			servo1(370, 250);
			servo4(300, 150);
			servo2(450,420);
			servo1(250,370);
			servo3(370,316);
			
			if(d==clk)
			{
				if((p==5) || (p==6))
				{
					servo0(780,316);
					//stepper(stepac, 1800);
				}
				
				else if(p==7)
				{
					servo0(780,850);
					//stepper(stepac,200);
				}
				else if((p==8) || (p==9))
				{
					servo0(780,97);
					//stepper(stepac,1000);
				}
			}
			else if(d==anclk)
			{
				if((p==5) || (p==6))
				{
					servo0(780,850);
					//stepper(stepac, 200);
				}
				
				else if(p==7)
				{
					servo0(780,316);
					//stepper(stepac,1800);
				}
				else if((p==8) || (p==9))
				{
					servo0(780,97);
					//stepper(stepac,1000);
				}
				
			}
			servo2(420,450);
			break;
		}
		case 2:
		{
			servo2(450,420);
			servo0(97,1000);
			//stepper(stepc, 200);
			servo2(420,450);
			servo3(316,370);
			servo1(370, 250);
			servo4(300, 150);
			servo2(450,420);
			servo1(250,370);
			servo3(370,316);
			if(d==clk)
			{
				if(p==5 || p==6)
				{
					servo0(1000,316);
					//stepper(stepac, 1000);
				}
				
				else if(p==7)
				{
					servo0(1000,850);
					//stepper(stepc,600);
				}
				else if(p==8 || p==9)
				{
					servo0(1000,97);
					//stepper(stepac,200);
				}
			}
			else if(d==anclk)
			{
				if(p==5 || p==6)
				{
					servo0(1000,850);
					//stepper(stepc, 600);
				}
				else if(p==7)
				{
					servo0(1000,316);
					//stepper(stepac,1000);
				}
				else if(p==8 || p==9)
				{
					servo0(1000,97);
					//stepper(stepac,200);
				}
				
			}
			servo2(420,450);
			break;
		}
		case 3:
		{
			servo2(450,420);
			servo0(97,243);
			//stepper(stepac,200 );
			servo2(420,450);
			servo3(316,370);
			servo1(370, 250);
			servo4(300, 150);
			servo2(450,420);
			servo1(250,370);
			servo3(370,316);
			if(d==clk)
			{
				if(p==5 || p==6)
				{
					servo0(243,316);
					//stepper(stepac, 600);
				}
				
				else if(p==7)
				{
					servo0(243,850);
					//stepper(stepc,1000);
				}
				else if(p==8 || p==9)
				{
					servo0(243,97);
					//stepper(stepc,200);
				}
			}
			else if(d==anclk)
			{
				if(p==5 || p==6)
				{
					servo0(243,850);
					//stepper(stepc, 1000);
				}
				else if(p==7)
				{
					servo0(243,316);
					//stepper(stepac,600);
				}
				else if(p==8 || p==9)
				{
					servo0(243,97);
					//stepper(stepc,200);
				}
				
			}
			servo2(420,450);
			break;
		}
		case 4:
		{
			servo2(450,420);
			servo0(97,460);
			servo2(420,450);
			//stepper(stepac, 1400);
			servo3(316,370);
			servo1(370, 250);
			servo4(300, 150);
			servo2(450,420);
			servo1(250,370);
			servo3(370,316);
			if(d==clk)
			{
				if(p==5 || p==6)
				{
					servo0(460,316);
					//stepper(stepc, 200);
				}
				
				else if(p==7)
				{
					servo0(460,850);
					//stepper(stepc,1800);
				}
				else if(p==8 || p==9)
				{
					servo0(460,97);
					//stepper(stepc,1000);
				}
			}
			else if(d==anclk)
			{
				if(p==5 || p==6)
				{
					servo0(460,850);
					//stepper(stepc, 2200);
				}
				else if(p==7)
				{
					servo0(460,316);
					//stepper(stepac,600);
				}
				else if(p==8 || p==9)
				{
					servo0(460,97);
					//stepper(stepc,1400);
				}
				
			}
		}
		servo2(420,450);
		break;
	}
	
}

void pop(int val,int node_value)
{
	//0 9
	int i;
	//pick 
	if(val>0)
	{ 
		//which place is empty in bot for CM to place
		for(i=0;i<4;i++)
		{
			
			if(CM_place_in_bot[i]==0)
				break;
		}
		// 5 out 6 in
		if(mat_remain[node_value-1])
		{
			papom(5,i+1,node_value);
			CM_place_in_bot[i]=node_value;
			mat_remain[node_value-1]--;
		}
		else
		{
		  papom(6,i+1,node_value);
		  CM_place_in_bot[i]=node_value;
		  //no need i think
		 /* mat_remain[node_value-1];*/
		}
	}
	//place
	else
	{
		//place1,2,3,4-on the bot, 5-outside low rise, 6- outside high rise , 7-inside, 8-front low rise, 9-front high rise
		int a=0;
		for(i=0;i<4;i++)
		{
			int place;
			if(mat_req_for_house[node_value-7]>0)
			{
				if(CM_place_in_bot[i]==CM[2*(node_value-7)+a])
				{
					int state;
					//in front facing
					if(f==1)
					{
						//high rise
					  if(high_or_low[node_value-7])
						place=9;
						//low rise
					  else
					   place=8;
					}
					else
					{
						//h5
						if(node_value==11)
							place=7;
							//other houses
						else
						{
							if(high_or_low[node_value-7])
								place=6;
							else
								place=5;
						}
					}
					LCD_Clear();
					unsigned char c[10];
					itoa(i+1,c,10);
					LCD_String_xy(1,0,c);
					LCD_String_xy(0,1,"place krunga");
					_delay_ms(1000);
					LCD_Clear();
					papom(i+1,place,node_value);
					CM_place_in_bot[i]=0;
					i=-1;
					a++;
					mat_req_for_house[node_value-7]--;
					
				}
			}
			else
				break;
			
		}
	}
	
}
void papom(int pick, int place,int node)
{
// 	velocity(120,120);
// 	forward();
// 	_delay_ms(800);
// 	read_wls();
		if(node!=11)
		{
			left=0;
			right=0;
			if((wls_middle>100 && wls_right>100 && wls_left>100))
			{
				while(left<170 && right<170)
				{
					velocity(150,132);
					forward();
				}
			}
	
			stopmm();
			wls_print();
			_delay_ms(1000);
			while(wls_middle<70)
			{
				if(wls_left>50 )
					turn_left();
				else if(wls_right>50 )
					turn_right();
				_delay_ms(10);
				read_wls();
			}
		}
	stopmm();
		int i;
		//direction ==1, clockise        direction ==0, anticlockwise
		//pick 1,2,3,4-on the bot, 5-outside, 6-inside
		//place1,2,3,4-on the bot, 5-outside low rise, 6- outside high rise , 7-inside, 8-front low rise, 9-front high rise
		if(direction==clk)
		{
			if(pick>0 )
			{
				switch(pick)
				{
					case 1:
					{
						pick_from(direction,pick,place);
						break;
					}
					case 2:
					{
						pick_from(direction,pick,place);
						break;
					}
					case 3:
					{
						pick_from(direction,pick,place);
						break;
					}
					case 4:
					{
						pick_from(direction,pick,place);
						break;
					}
					case 5:
					{
						servo0(97,316);
						//stepper(stepac, 800);
						pick_bot();
						break;
						
					}
					case 6:
					{
						servo0(97,850);
						//stepper(stepc, 780);
						pick_bot();
						break;
					}
				}
				
			}
			
			if(place>0)
			{
				switch(place)
				{
					case 1:
					{
						place_in(direction,pick, place);
						break;
					}
					case 2:
					{
						place_in(direction,pick, place);
						break;
					}
					case 3:
					{
						place_in(direction,pick, place);
						break;
					}
					case 4:
					{
						place_in(direction,pick, place);
						break;
					}
					case 5:
					{
						place_lr();
						
						servo0(316,97);
						//stepper(stepac,800);
						
						break;
					}
					case 6:
					{
						place_hr();
						servo0(316,97);
						//stepper(stepc,800);
						break;
					}
					case 7:
					{
						servo2(450,350);
						servo1(370,206);
						servo4(150,300);
						servo1(206,370);
						servo2(350,450);
						servo0(850,97);
						//stepper(stepac,800);
						break;
					}
					case 8:
					{
						place_lr();
						break;
					}
					case 9:
					{
						place_hr();
						break;
					}
				}
			}
			
		}
		else if(direction==anclk)
		{
			if(pick>0 )
			{
				switch(pick)
				{
					case 1:
					{
						pick_from(direction,pick,place);
						break;
					}
					case 2:
					{
						pick_from(direction,pick,place);
						break;
					}
					case 3:
					{
						pick_from(direction,pick,place);
						break;
					}
					case 4:
					{
						pick_from(direction,pick,place);
						break;
					}
					case 5:
					{
						servo0(97,850);
						//stepper(stepc, 800);
						pick_bot();
						break;
						
					}
					case 6:
					{
						servo0(97,316);
						//stepper(stepac, 800);
						pick_bot();
						break;
					}
				}
				
			}
			
			if(place>0)
			{
				switch(place)
				{
					case 1:
					{
						place_in(direction,pick, place);
						break;
					}
					case 2:
					{
						place_in(direction,pick, place);
						break;
					}
					case 3:
					{
						place_in(direction,pick, place);
						break;
					}
					case 4:
					{
						place_in(direction,pick, place);
						break;
					}
					case 5:
					{
						place_lr();
						servo0(850,97);
						//stepper(stepac,800);
						
						break;
					}
					case 6:
					{
						place_hr();
						servo0(850,97);
						//stepper(stepac,800);
						break;
					}
					case 7:
					{
						servo2(450,350);
						servo1(370,206);
						servo4(150,300);
						servo1(206,370);
						servo2(350,450);
						servo0(316,97);
						//stepper(stepac,800);
						break;
					}
					case 8:
					{
						place_lr();
						break;
					}
					case 9:
					{
						place_hr();
						break;
					}
				}
			}
			
		}
				
	
}

void wall_follower()
{
	line_follower();
	velocity(130,130);
	ir();
	while(ir_left>55)
	{
		
		ir();
		read_wls();
		if(wls_left>100 || wls_middle>100 || wls_right>100)
		{
			break;
		}
		if(ir_left<90)
		{
			soft_left();
		}
		else if(ir_left>95)
		{
			soft_right();
		}
		else
		{
			forward();
		}
		_delay_ms(100);
	}
	
	forward_wls(1,150);
}

void ir()
{
	ADMUX = 0xA4;
	ADCSRA |= (1 << ADEN);  // Enable ADC
	ADCSRA |= (1 << ADSC);  // Start A2D Conversions
	while(ADCSRA & (1<<ADSC)){}
	ir_right=ADCH;
	ADMUX = 0xA5;
	ADCSRA |= (1 << ADEN);  // Enable ADC
	ADCSRA |= (1 << ADSC);  // Start A2D Conversions
	while(ADCSRA & (1<<ADSC)){}
	ir_left=ADCH;
}
int availableMemory() {
	int size = 8192; // Use 2048 with ATmega328
	byte *buf;

	while ((buf = (byte *) malloc(--size)) == NULL);

	free(buf);

	return size;
}

int main(void)
{
	_delay_ms(3000);
 	
	all_init();
	direction=anclk;
	//follow_white_line(1,1,9);
	task5();
	//papom(2,7,11);
	//pop(0,11);
	 
	
	return 0;
}
void task5()
{
		f=0;
		direction = clk;
		all_init();
		//LCD_Init();
		make_path();
		unsigned char c[10];
		//array to store node value of CM  and house
		//					 M1  M2 M3  M4 M5  M6 H1  H2 H3  H4 H5
		int node_value[11]={ 15, 3, 13, 5, 11, 7, 14, 4, 12, 6, 9};
		int size = availableMemory();
		
		LCD_Clear();

		itoa(size, c, 10);
		LCD_String(c);
		LCD_String_xy(1,1,"PHLE");
		_delay_ms(1000);
		LCD_Clear();

		LCD_Clear();
		for(int i=0;i<17;i++)
		{
			
			
			itoa(or_path[i], c, 10);
			
			if(i<9)
			LCD_String_xy(0,2*i,c);
			else
			LCD_String_xy(1,2*(i-9),c);
			_delay_ms(1000);
		}
		LCD_Clear();
		
		
		LCD_String_xy(0,0,"start");
		itoa(node_value[or_path[0]-1], 7, 10);
		
		LCD_String_xy(0,4,c);
		LCD_String_xy(1,2,"ja rha");
		_delay_ms(500);

		//travel from start to or_path[0]
		shortest_path(1,node_value[or_path[0]-1]);
		pop(1,or_path[0]);
		
		//first going to H5
		for(int i=0;i<4;i++)
		{
			LCD_Clear();
			itoa(node_value[or_path[i]-1], c, 10);
			
			LCD_String_xy(0,0,c);
			
			itoa(node_value[or_path[i+1]-1], c, 10);
			
			LCD_String_xy(0,3,c);
			LCD_String_xy(1,0,"ja rha");
			_delay_ms(500);

			

			shortest_path(node_value[or_path[i]-1],node_value[or_path[i+1]-1]);
			//1  4 6 6 11
			if(i==3)
				pop(0,or_path[i+1]);
			
			else
				pop(1,or_path[i+1]);
		}
		for(int i=4;i<14;i++)
		{
			
			LCD_Clear();
			itoa(node_value[or_path[i]-1], c, 10);
			
			LCD_String_xy(0,0,c);
			
			itoa(node_value[or_path[i+1]-1], c, 10);
			
			LCD_String_xy(0,2,c);
			LCD_String_xy(1,2,"ja rha");
			_delay_ms(500);

			
            if(or_path[i+1]!=0)
			{
				shortest_path(node_value[or_path[i]-1],node_value[or_path[i+1]-1]);
				pop(i%3,or_path[i+1]);	
			}
			else
			{
				i++;
				if(or_path[i+1]!=0)
				{
					shortest_path(node_value[or_path[i-1]-1],node_value[or_path[i+1]-1]);
					pop(i%3,or_path[i+1]);
				}
				else
				{
					i++;
					shortest_path(node_value[or_path[i-1]-1],node_value[or_path[i+2]-1]);
					pop(0,or_path[i+1]);
				}
			}
		}
		//
		size = availableMemory();
		LCD_Clear();

		itoa(size, c, 10);
		LCD_String(c);
		LCD_String_xy(1,1,"PHLE");
		_delay_ms(1000);
		
		
		
		//
		// 	shortest_path(1,3);
		// 	papom(direction,5,1);
		// 	papom(direction,6,3);
		// 	shortest_path(3,4);
		// 	papom(direction,1,5);
		// 	papom(direction,3,5);
		
		
		//stopmm();      //after everything
		
		return 0;
}





//  	 delete_list(head);
//  	 LCD_Clear();
//  	 for(int i=0;i<12;i++)
//  	 {
	 	 
	 	 
// 	 	 itoa(or_path[i], c, 10);
// 	 	 LCD_String(c);
	 	 
// 	 	 LCD_String_xy(0,i,c);
// 	 	 _delay_ms(1000);
//  	 }
 	 //LCD/*_Clear();*/
